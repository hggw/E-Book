# 一、Kubernetes介绍

## 1 容器技术

### 1.1 Linux容器技术

Linux容器技术允许在同一台机器上运行多个服务，不仅提供不同的环境给每个服务，而且将它们互相隔离。一个容器里运行的进程实际上运行在宿主机的操作系统上。

和虚拟机比较，容器更加轻量级，允许在相同的硬件上运行更多数量的组件。主要是因为每个虚拟机需要运行自己的一组系统进程，产生了除组件进程小号意外的额外计算资源损耗。而容器仅仅是运行在宿主机上被隔离的单个进程，仅消耗应用容器消耗的资源。

![](images\K8S01.png)

运行在虚拟机里的应用程序会执行虚拟机操作系统的系统调用，然后虚拟机内核会通过管理程序在宿主机上的物理CPU执行x86指令。

多个容器则会完全执行运行在宿主机上的同一个内核的系统调用，此内核是唯一在宿主机擦操作系统上执行下x86指令的内核。

![](images\K8S02.png)

![](images\K8S03.png)

### 1.2 容器的隔离机制

主要涉及两个机制：**Linux命名空间**和**Linux控制组（cgroups）**

#### 1.2.1 Linux命名空间

Linux控制组使每个进程只看到他自己的系统试图（文件、进程、网络接口、主机名等）。默认情况下，每个Linux系统最初仅有一个命名空间，所有系统资源都属于这个命名空间，但用户可以创建额外的命名空间以及在它们之间组织资源。

对于一个进程，可以在其中一个命名空间中运行它，进程将只能看到同一个命名空间下的资源。

命名空间有以下几种类型，每种命名空间被用来隔离一组特定的资源：

1. Mount（mnt）

2. Process ID(pid)

3. NetWork(net)

   决定了运行在进程里的应用程序能看见什么网络接口，每个网络接口属于一个命名空间，但允许在命名空间之间转移。每个容器仅能看见他自己的一组网络接口。

4. Inter-process communication(ipd)

5. UTS

   决定了运行在命名空间里的进程能看见哪些主机名和域名，通过分派两个不同的UTS命名空间给一对进程，能使它们看见不同的本地主机名。

6. User ID(user)

#### 1.2.2 Linux控制组（cgroups）

这是Linux的内核功能，被用来限制一个进程或者一组进程的资源使用量（CPU、内存、网络带宽等）不超出被分配的量。

### 1.3 Docker容器平台

基于Docker容器的镜像是由多层构成，它能在多个镜像之间共享和征用。

#### 1.3.1 Docker的概念

Docker是一个打包、分发和运行应用程序的平台，允许将应用程序及其所以来的整个环境打包在一起。主要三个概念：

- **镜像**：Docker镜像里包含了打包的应用陈鼓型机器所依赖的环境。
- **镜像仓库**：Docker镜像仓库用于存放Docker镜像以及促进不同人和不同电脑之间共享这些镜像。
- **容器**：Docker容器通常是一个Linux容器，基于Docker镜像被创建。一个运行中的容器是一个运行在Docker主机上的进程，但它和主机，以及所有运行在主机上的其他进程都隔离的。

#### 1.3.2 Docker镜像

开发人员首先构建一个镜像推到镜像仓库中，再将镜像拉去到任何运行着Docker的机器上并运行镜像。Docker会基于镜像创建一个独立的容器，并运行二进制可执行文件指定其作为镜像的一部分。

![](images\K8S04.png)

##### 1.3.2.1 镜像层

应用A和应用B作为两个分离容器运行时可以访问相同的二进制文件和依赖库。我们知道每个容器有它自己隔离的文件系统，不同应用之间如何共享同样的文件？这就涉及了镜像文件中的**镜像层**概念。

![](images\K8S05.png)

Docker镜像由多层构成，不同镜像可能包含完全相同的层，因为这些镜像是基于另一个镜像构建的，不同的镜像能使用相同的父镜像作为它们的基础镜像。

当基于相同基础层的镜像被创建成两个容器是，它们能读相同的文件，但如果其中一个容器写入某些文件，另外一个是无法看见文件变更的。因为容器镜像层是只读的。容器运行时，一个新的可写层在镜像层上被创建。**容器中进程写入位于底层的一个文件时，此文件的一个拷贝在顶层被创建，进程写的是此拷贝**。

由于一台机器上所有容器共享主机Linux内核，如果一个应用需要一个特定的内核版本，那它可能无法在每台机器上都正常运行。

## 2 Kubernetes介绍

### 2.1 Kubernetes核心功能

整个系统由一盒注解点和若干个工作节点组成。开发者把一个应用列表提交到主节点，Kubernetes将其部署到集群的工作节点。

![](images\K8S06.png)

### 2.2 Kubernetes集群架构

Kubernetes集群由很多节点组成，主要分成一下两种类型：

- **主节点**：承载Kubernetes控制和管理整个集群系统的控制面板
- **工作节点**：运行用户实际部署的应用

![](images/K8S07.png)

#### 2.2.1 控制面板

包含多个组件，每个组件都可以运行在单个主节点或者通过副本分别部署在多个主节点以确保高可用性。这些组件是：

- **Kubernetes API服务器**：用户和其他控制面板组件与其进行通讯
- **Scheculer**：应用调度，为应用的每个可部署组件分配一个工作节点
- **Controller Manager**：执行集群级别的功能，如复制组件、持续跟踪工作节点、处理节点失败等
- **etcd**：分布式数据存储，能持久化存储集群配置

#### 2.2.2 工作节点

工作节点是运行容器化应用的机器。运行、监控和管理应用服务由以下组件完成：

- Docker、rkt或其他容器类型
- Kubelet：与API服务器通信，管理所在节点的容器
- Kubernetes Service Proxy(kube-proxy)：负责组件之间的负载均衡网络流量

### 2.3 在Kubernetes中运行应用

在Kubernetes中运行应用，首先要将应用打包斤一个或多个容器镜像，再将哪些镜像推送到镜像仓库，然后将应用的描述发布到Kubernetes API服务器。

当API服务器处理应用的描述时，调度器调度指定组的容器到可用的工作之后节点上，调度是基于每组所需的计算资源，以及调度时每个节点未分配的资源。之后，节点上的Kubelet指示容器拉去所需的镜像，并运行容器。

![](images/K8S08.png)

# 二、运行于Kubernetes中的容器

## 1 pod介绍

pod是一组并置的容器，代表Kubernetes中的基本构建模块。实际应用中更多的是针对一组pod的容器进行部署和操作。**当一个pod包含多个容器时，这些容器总是运行于同一个工作节点上——一个pod不会跨越多个工作节点**。

![](images/K8S09.png)

在Kubernetes中，我们经常在容器中运行进程，每一个容器都非常像一台独立的机器。若单个容器中运行多个不相关的进程，那么保持所有进程运行、管理它们的日志等需要用户进行管理，显然这不符合Kubernetes的初衷。综上所述，**每个容器只运行一个进程（除非进程本身产生子进程**）。

### 1.1 了解pod

由于不能将多个进程聚集在一个单独的容器中，需要另一种更高级的结构，将**容器绑在一起，作为单元进程管理**，这个结构就是pod。在包含容器的pod下，同时运行一些密切相关的进程，并为它们提供相同的环境，这些进程好像全部运行于单个容器中一样，同时有保持着一定的隔离。

1. **同一pod中容器之间的部分隔离**

   1. Kuberenets通过配置Docker来让一个pod内的所有容器共享相同的Linux命名空间，所有容器都在相同的network和UTS命名空间下运行，共享相同的主机名和网络接口。

   涉及文件系统时，由于大多数容器的文件系统来自容器镜像，因此默认情况下，每个容器的文件系统与其他容器完全隔离。

2. **容器共享相同的IP和端口空间**

   由于同一个pod中的容器运行于相同的Network命名空间中，享有相同的IP地址和端口空间，这意味者同一pod总的容器运行的多个进程不能绑定到相同的端口号。对于不同pod的容器则不会有这样的情况。

   一个pod中所有容器具有相同的lookback网络接口，因此容器可以通过localhost与同一pod中的其他容器进行通信。

3. **pod间网络**

   Kuberenets集群的所有pod都在同一共享网络地址空间中，每个pod都可以通过其他pod的IP地址实现互相访问，不存在NAT(网络地址转换)网关。

   

综上，pod与非容器时间中的物理主机或虚拟级非常相似，运行在同一个pod中的进程与运行在同一物理机或虚拟级上的进程相似，只是每个进程都封装在一个容器之中。

### 1.2 通过pod合理管理容器

